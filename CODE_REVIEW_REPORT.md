# Полный отчёт код-ревью: ShlapaBank

Независимый экспертный разбор кода с точки зрения логики, валидации, ограничений, тестируемости (API/UI), вложенных структур и возможных улучшений (включая кеш).

---

## 1. Общая оценка и структура

**Плюсы:**
- Чёткое разделение: модели, схемы, роуты, security, banks, otp.
- FastAPI + Pydantic + SQLAlchemy — современный стек.
- API-тесты против живого сервера — хорошая практика для интеграции.
- Бизнес-правила (лимиты, OTP, блокировка по попыткам входа) реализованы явно.

**Минусы / риски:**
- Нет слоя сервисов: бизнес-логика размазана по роутам (дублирование проверок, сложнее тестировать unit-тестами).
- Конфиг через `os.getenv` без типов и валидации.
- Нет кеширования.
- Часть валидации только в роутах, часть в схемах — нет единого подхода к ограничениям и сообщениям об ошибках.

---

## 2. Модели и БД (models.py)

### 2.1 Вложенные классы и связи

Сейчас:
- Есть только «плоские» модели и enum'ы.
- Связи: `User.accounts`, `User.transfer_banks`; у `Account` — `owner`; у `Transaction` — только FK, без `relationship` на `Account`/`User`.

Рекомендации для тренировки и удобства API:
- Добавить на `Account`: `transactions_from`, `transactions_to` (или общий `transactions` через hybrid).
- Добавить на `Transaction`: `from_account`, `to_account`, `initiator` (relationship на `User`) — тогда в тестах и при отладке можно проверять загрузку вложенных структур.
- Вынести константы лимитов (например `MIN_AMOUNT`, `MAX_AMOUNT`, `DAILY_LIMIT`) в один модуль (например `app/constants.py` или в конфиг) и при желании дублировать ограничения на уровне БД (CHECK) для согласованности.

### 2.2 Ограничения на уровне БД

Сейчас:
- `UniqueConstraint("user_id", "bank_code")` в `UserBank` — хорошо.
- Остальные ограничения только на длину/тип колонок.

Рекомендации:
- `Account.balance`: добавить `CheckConstraint("balance >= 0", name="ck_account_balance_non_negative")`.
- При желании усилить тренировку: CHECK на длину `account_number`, на формат (например только цифры для части масок).
- `User.phone`: при необходимости единообразия с маской — CHECK в духе `phone IS NULL OR phone ~ '^\+7[0-9]{10}$'` (PostgreSQL).

### 2.3 Номер счёта (маска)

В `accounts.py` маска по валюте (2202/3202/4202/5202) реализована в коде. В БД хранится уже сгенерированная строка. Для тестов и валидации полезно:
- Иметь явный справочник масок (префикс по валюте, длина, допустимые символы) в одном месте.
- В Pydantic-схемах для ответа можно добавить валидатор/сериализатор, который проверяет соответствие номера маске (для ответов и тестов).

---

## 3. Валидация (schemas.py, security.py, роуты)

### 3.1 Схемы (Pydantic)

**Сильные стороны:**
- `RegisterRequest`: `min_length`, `max_length`, `pattern` для логина; пароль по длине.
- Телефон: `pattern=r"^\+7\d{10}$"` в нескольких местах.
- OTP: `min_length=4, max_length=4, pattern=r"^\d{4}$"`.
- Суммы: `Decimal`, `Field(gt=0)` где нужно.
- `ProfileUpdateRequest`: имена с паттерном (латиница + кириллица).

**Проблемы и улучшения:**

| Место | Проблема | Рекомендация |
|-------|----------|--------------|
| `LoginRequest` | Нет ограничений на `login`/`password` (пустая строка, длина) | Добавить `min_length=1` на оба поля или вынести общий `LoginCredentials` с pattern для логина. |
| `ProfileUpdateRequest` | `first_name`/`last_name`: только буквы, без пробелов и дефисов | Для «тренировки» можно ввести опциональный паттерн с дефисом/пробелом или отдельные правила для фамилии. |
| `UserBanksUpdateRequest` | `Field(max_length=5, min_length=0)` для списка — в Pydantic v2 это `max_length` на длину списка | Уточнить: нужен ли явно `max_length=5` через `Field` для list; при необходимости добавить `field_validator`, проверяющий уникальность кодов. |
| `VendorPaymentRequest` | `account_number` без формата/длины в схеме | Добавить `min_length=1`, `max_length=30` или принять список допустимых длин из конфига/справочника и валидировать в `model_validator`. |
| `TransferByAccountRequest` | `target_account_number`: только `min_length=1, max_length=32` | При наличии маслы счёта — проверка формата (например только цифры, префикс 2202/3202/…) в валидаторе. |
| Дублирование OTP-поля | Один и тот же `Field(...)` для `otp_code` повторяется во многих схемах | Вынести в общий тип, например `OtpCode = Annotated[str, Field(min_length=4, max_length=4, pattern=r"^\d{4}$")]`, и использовать в запросах. |

### 3.2 Валидация пароля (security.py)

- Проверка «пароль ≠ логин», пробелы, regex — хорошо.
- Не вызывается из `LoginRequest` при логине (логин может быть пустым до попадания в хендлер). Достаточно добавить валидацию длины в схеме логина и оставить детальные правила в `validate_password_rules` для регистрации и смены пароля.

### 3.3 Ограничения в роутах (дублирование)

Одни и те же проверки повторяются в нескольких эндпоинтах:
- `payload.amount < MIN_AMOUNT` / `> MAX_AMOUNT`;
- `_calc_today_transfers_rub` + сравнение с `DAILY_LIMIT`;
- проверка OTP, активного счёта, «не с SAVINGS», валюта, баланс.

Рекомендации:
- Вынести в общие функции (например в `app/services/transfer.py`): `validate_transfer_limits(amount, ...)`, `ensure_can_debit_from_account(account, user, amount)` и т.д. — так проще покрывать unit-тестами и не дублировать код.
- Лимиты `MIN_AMOUNT`, `MAX_AMOUNT`, `DAILY_LIMIT` читать из конфига (или constants), чтобы можно было менять без правок кода.

---

## 4. Маски и форматы

- **Телефон:** везде `+7XXXXXXXXXX` — единообразно, хорошо.
- **Номер счёта:** префикс по валюте (2202/3202/4202/5202), остальное цифры. Имеет смысл описать маску в одном месте (длина 16, символы 0–9) и при необходимости проверять в API ответах или в тестах.
- **Логин:** `^[A-Za-z0-9]+$`, 6–20 символов — ок.
- **Имена:** только буквы (латиница + кириллица). Для реального использования стоит обсудить дефисы/пробелы; для тренировки можно добавить более сложный regex.

---

## 5. Конфигурация (config.py)

Сейчас:
- Класс `Settings` с `os.getenv` и приведением типов вручную (`int(...)`).
- Нет валидации (пустой `SECRET_KEY`, неверный `DATABASE_URL` не отловлены при старте).

Рекомендации:
- Перейти на `pydantic-settings` (BaseSettings): типы, валидация, `.env` из корня проекта. Так проще добавлять новые переменные и тестировать конфиг.
- Вынести лимиты приложения (суммы, лимит банков 0–5, лимит попыток входа 5, OTP TTL и т.д.) в конфиг или constants — единая точка правды.

---

## 6. Кеширование

Сейчас кеша нет: каждый запрос идёт в БД.

Идеи для тренировки и улучшения:
- **Курсы валют** (`/transfers/rates`): кеш в памяти (например `cachetools.TTLCache`) или Redis с TTL 1–5 минут — снижает нагрузку и даёт сценарии тестов «кеш просрочен / не просрочен».
- **Справочники:** операторы мобильной связи, поставщики ЖКХ — редко меняются, можно кешировать ответ GET на 5–15 минут.
- **daily_usage:** тяжёлый запрос по транзакциям за день; короткий TTL (30–60 сек) или инвалидация при создании новой транзакции — хороший кейс для тестов «до/после операции».
- **OTP:** сейчас in-memory; при нескольких воркерах нужен общий store (Redis). Для тестов можно оставить in-memory + документировать ограничение.

Это даёт сценарии для API-тестов: проверка заголовков кеша, повторный запрос без изменения данных, инвалидация после операции.

---

## 7. API-тесты (backend/tests)

**Плюсы:**
- Фикстуры (client, token, registered_user, rub_account, two_rub_accounts, admin_token).
- Покрытие основных сценариев: успех, 400/401/403/404, валидация полей (422).
- Использование helper (increase, zero) для подготовки данных.

**Что улучшить / усложнить для тренировки:**

1. **Параметризация:** дублирующиеся проверки (неверный OTP, недостаточно средств, лимиты) оформить как `@pytest.mark.parametrize` по эндпоинту и ожидаемому коду/детали.
2. **Граничные значения:** явные тесты на `amount = MIN_AMOUNT`, `MAX_AMOUNT`, ровно `DAILY_LIMIT`, `DAILY_LIMIT + 0.01`; количество счетов (3 RUB, 4-й — 400); банки (5 внешних — ок, 6-й — 400).
3. **Вложенные ответы:** если в API появятся ответы с вложенными объектами (например транзакция с `from_account: { id, account_number }`), добавить тесты на структуру и типы полей (например через jsonschema или Pydantic).
4. **Контракты:** опционально — сохранение OpenAPI в файл и тесты «ответ эндпоинта соответствует схеме» (например с помощью `pydantic` или `prism`).
5. **Негатив:** больше сценариев «чужая сущность» (перевод с чужого счёта, закрытие чужого счёта, смена банков другого пользователя без админа).
6. **Админ:** тесты на повторный block/unblock, credit с нулем/отрицательной суммой (если схема разрешит — 422), несуществующий account_id.

---

## 8. UI и UI-тесты

- Мок ап — один HTML + JS, запросы к API, маппинг ошибок в `mapApiError`.
- Для тренировки UI-тестов можно:
  - Добавить стабильные `data-testid` или `data-qa` на ключевые кнопки и поля (логин, пароль, кнопка «Войти», счета, форма перевода, OTP).
  - Описать 2–3 сценария E2E (Playwright/Selenium): логин → список счетов; перевод между счетами с вводом OTP; отображение ошибки при неверном OTP.
  - Проверять отображение ошибок: при 400/403 убедиться, что в интерфейсе показывается нужный текст из `mapApiError`.

---

## 9. Вложенные структуры для практики

Сейчас в ответах в основном плоские объекты. Чтобы потренировать вложенные классы и тесты по ним:

1. **Ответ «транзакция с счетами»:**  
   Ввести схему вида `TransactionWithAccountsPublic(TransactionPublic)` с опциональными полями `from_account: AccountPublic | None`, `to_account: AccountPublic | None` и отдавать в отдельном эндпоинте (например `GET /transactions?embed=accounts`) или в админском списке транзакций.
2. **Ответ «дневной лимит по счетам»:**  
   Уже есть вложенная структура `perAccountDaily`; оформить её как Pydantic-модель (например `AccountDailyUsage`, `DailyUsageResponse`) и использовать `response_model=DailyUsageResponse` — тесты смогут проверять типы и вложенность.
3. **Профиль с последними счетами:**  
   Например `ProfileWithAccountsResponse(UserPublic, accounts: list[AccountPublic])` — один запрос для дашборда и тест на вложенный список.
4. **Справочник поставщиков с категориями:**  
   Сейчас в payments — плоский словарь. Можно добавить категории (ЖКХ, интернет, образование) и отдавать `list[CategoryWithProviders]` с вложенными провайдерами — хорошая практика для вложенных схем и тестов.

---

## 10. Безопасность и мелочи

- **JWT:** в payload только `sub` (id) и `exp` — нормально. При необходимости можно добавить `role` для быстрой проверки без БД (с осторожностью при смене роли).
- **Блокировка по попыткам входа:** порог 5 и сброс при успехе — логично; имеет смысл вынести 5 в конфиг.
- **CORS:** жёстко заданы localhost:8080 — для прода вынести в конфиг.
- **Helper-эндпоинты:** увеличение/обнуление баланса — только для тестов; в проде их нужно отключать по флагу или окружению.

---

## 11. Сводка рекомендаций

| Область | Действие |
|---------|----------|
| **Валидация** | Единый тип для OTP; валидация логина/пароля в LoginRequest; опционально — валидатор номера счёта по маске; вынести лимиты в конфиг/constants. |
| **Ограничения** | CHECK на `balance >= 0`; при желании — CHECK на формат телефона; лимиты в одном месте. |
| **Маски** | Один справочник масок счёта (префикс, длина, символы); при необходимости — проверка в ответах/тестах. |
| **Вложенные классы** | Транзакция с вложенными счетами; Pydantic-модели для daily_usage; профиль с счетами; категории поставщиков. |
| **Конфиг** | pydantic-settings; лимиты и пороги из конфига. |
| **Кеш** | TTL-кеш для rates, справочников, при желании — для daily_usage; документировать и покрыть тестами. |
| **Слой сервисов** | Вынести проверки переводов/лимитов в сервисы; уменьшить дублирование в роутах. |
| **API-тесты** | Параметризация, граничные значения, тесты вложенных структур и контрактов, негатив по доступу. |
| **UI-тесты** | data-testid, 2–3 E2E сценария, проверка отображения ошибок. |

Если нужно, могу предложить конкретные патчи по файлам (например, только валидация и константы или только вложенные схемы и кеш).
